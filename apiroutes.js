const express = require('express');
const path = require('path');

const winston = require('winston');
const pick = require('lodash.pick');
const Promise = require('bluebird');
const Fuse = require('fuse.js');

const apputils = require('./utils');
const filtercache = require('./filtercache');
const cmscontent = require('./cmscontent');

const fs = Promise.promisifyAll(require('fs'));

/**
 * Log level
 */
winston.level = process.env.LOG_LEVEL || 'error' ;

var router = express.Router();

/**
 * Utility function to allow wrapping every call in the express route with async
 * @param {function} fn 
 */
const asyncUtil = fn =>
        (req, res, next) =>
          fn(req, res, next)
            .catch(next);
 
            /*
router.get(
  '/searchFilter',
  asyncUtil( async (req, res, next) => {
    const filterObj = filterbuilder.searchFilter(req, res, next);
    const data = await filterbuilder.searchFilterQuery(filterObj);
    res.json(data)
  }
  )
);

*/

router.get(
  '/content',
   (req, res, next) => {
    const pageName = req.query.page;
    const lang = req.query.lang;
    const html = cmscontent.serveFile(
      req, 
      res, 
      next, 
      pageName,
      lang
    );
  }
);


/**
 * Accepts a Keyword URL parameter and returns matches for it from the full filter cache
 * /keyword?kw=Acco 
 */
router.get(
  '/keyword',
  findKeyword
);

const fuseOptions = {
  shouldSort: true,
  //includeScore: true,
  threshold: 0.6,
  location: 0,
  distance: 100,
  maxPatternLength: 32,
  minMatchCharLength: 2,
  keys: [
    "showAs"
  ]
};

async function fuseSearch(list, keyword) {
  let fuse = new Fuse(list, fuseOptions);
  let results = fuse.search(keyword);
  return results.slice(0, 50);
}

/**
 * Finds keywords using the full filter cache. 
 * NOTE: this makes use of the Promise form of the fs module.
 * where the APIs are generated by promisyfing fs using bluebird.
 * @param {object} req 
 * @param {object} res 
 * @param {object} next 
 */
function findKeyword(req, res, next) {
    const keyword = req.query.kw.toLowerCase() ;
    fs.openAsync(filtercache.getCacheFile(), 'r').then(
      function(fd) {
        fs.readFileAsync(filtercache.getCacheFile(), 'utf8')
          .then(
          function(contents) {
            let filterObj = JSON.parse(contents);
            let kwObjs = filterObj.filter.find(
              filter => filter.name === 'keywords'
            );
            apputils.fsClose(fs, fd);
            fuseSearch(kwObjs.keyword, keyword).then(
              (results) =>  res.json({matches: results})
            );
            /*
            fuzzysort.goAsync(keyword, kwObjs.keyword, {keys: ['showAs']})
              .then(results => {
                res.json({matches: results});
              });
              */
            /*
            let matches = kwObjs.keyword.filter(
               kwObj => kwObj.showAs.toLowerCase().indexOf(keyword) >= 0 
            );
            */
            //res.json({matches: matches});
          }
        ).catch(
          function (error) {
              winston.log(" error in findKeyword " + error.message);
          }
        );
    }
  );
}

/**
 * Accepts a Keyword Value parameter and returns full keyword objects for it from the full filter cache
 * /keyword?kwv=x&kwv=y 
 */
router.get(
  '/keywordValue',
  findKeywordValue
);

/**
 * Finds keyword objects using the full filter cache based on a filter value
 * NOTE: this makes use of the Promise form of the fs module.
 * where the APIs are generated by promisyfing fs using bluebird.
 * @param {object} req 
 * @param {object} res 
 * @param {object} next 
 */
function findKeywordValue(req, res, next) {
  const keywordValue = coerceIntoArray(req.query.kwv) ;
  
  fs.openAsync(filtercache.getCacheFile(), 'r').then(
    function(fd) {
      fs.readFileAsync(filtercache.getCacheFile(), 'utf8')
        .then(
        function(contents) {
          let filterObj = JSON.parse(contents);
          apputils.fsClose(fs, fd);
          let kwObjs = filterObj.filter.find(
            filter => filter.name === 'keywords'
          );
          let found = [];
          keywordValue.map( 
                (value) => {
                  let filterVal = kwObjs.keyword.find( 
                      (filter) => filter.value === value
                    );
                  if (filterVal !== undefined) {
                    found.push(filterVal);
                  }
                }
          );
          res.json({found: found}); 
        }
      ).catch(
        function (error) {
            winston.log(" error in findKeywordValue " + error.message);
        }
      ); 
    }
  );
  
}

const coerceIntoArray = (obj) => 
    Array.isArray(obj) ? obj : [obj] || [];

module.exports = router;
